# ✅ EF Core Entity & Migration Regeneration Guide  
**Location:** `.github/copilot-entity-generation.md`  
**Purpose:** Instructions for GitHub Copilot or developers to regenerate EF Core entities, configurations, and migrations from MySQL database.

---

## ✅ 1. Database Connection

The updated MySQL database uses this connection string:

```
ConnectionStrings__downstairsdb = Server=localhost;Port=3306;Database=downstairs;Uid=root;Pwd=password;CharSet=utf8mb4;
```

---

## ✅ 2. Required Actions

Follow these steps when regenerating EF Core models and migrations:

### **Step 1 — Clean Up Existing Code**
- Remove all existing EF Core entities (`/Models`) and previous migrations.
- Remove or clear old configuration classes in `Persistence/Configurations` (and matching repositories) so stale metadata does not survive the regeneration.
- Double-check `Persistence/Repositories` and supporting services for leftover references to tables that the database no longer contains.

---

### **Step 2 — Scaffold New Models from Database**
Use EF Core database-first scaffolding to generate new entities and `DownstairsDbContext` under `dotnet\src\Downstairs.Infrastructure\Persistence\Models`.

From the `dotnet` directory run:

```
dotnet ef dbcontext scaffold "Server=localhost;Port=3306;Database=downstairs;Uid=root;Pwd=password;CharSet=utf8mb4;" Pomelo.EntityFrameworkCore.MySql --project src/Downstairs.Infrastructure/Downstairs.Infrastructure.csproj --startup-project Downstairs.AppHost/Downstairs.AppHost.csproj --context DownstairsDbContext --context-dir Persistence --output-dir Persistence/Models --namespace Downstairs.Infrastructure.Persistence.Models --force --data-annotations
```

> ⚠️ **Before running the scaffold, copy the hand-written pieces that need to survive the overwrite.**
> - `DownstairsDbContext.OnConfiguring` must keep the `ConnectionStringHelper.Resolve("downstairsdb")` logic (no hard-coded connection string).
> - Namespace aliases such as `using TaskEntity = ...` prevent name collisions and must be restored immediately after scaffolding.
> - Any partial classes, extensions, or helper files that sit alongside scaffolded models need to remain untouched.

After scaffolding finishes, reapply those customizations so the solution continues to compile without warnings.

---

### **Step 3 — Post-Scaffold Cleanup**
- Compare the regenerated `Models` folder against source control and delete files for tables that no longer exist (e.g. the `ScheduleCleaning*` family removed in Oct 2025).
- Remove matching configuration/repository files for those dropped tables to avoid build errors.
- Keep `DownstairsDbContext.OnModelCreating` limited to the global `UseCollation`, `HasCharSet`, and `ApplyConfigurationsFromAssembly` calls—strip any per-entity configuration blocks reintroduced by scaffolding.

---

### **Step 4 — Correct Data Type Mappings**

Apply the following data type rules during or after scaffolding:

#### **C# Type Mappings**
| MySQL Type                     | C# Type |
|--------------------------------|---------|
| UNSIGNED BIGINT / UNSIGNED INT | `long`  |
| `ulong` (if generated by EF)   | Replace with `long` |
| `uint` / `ushort` (if generated) | Replace with `long` / project-approved signed type |

#### **SQL Column Type Rules in Configuration (`IEntityTypeConfiguration<T>`)**
| MySQL Column         | Use in `.HasColumnType(...)` |
|----------------------|------------------------------|
| `smallint`           | `smallint unsigned`          |
| `tinyint`            | `tinyint unsigned`           |
| `decimal(8,2)`       | `decimal(8,2) unsigned`      |

Example inside a configuration file:

```csharp
builder.Property(x => x.Status).HasColumnType("tinyint unsigned");
builder.Property(x => x.Level).HasColumnType("smallint unsigned");
builder.Property(x => x.Price).HasColumnType("decimal(8,2) unsigned");
```

---

### **Step 5 — Configure Many-to-Many Table Names**

**CRITICAL:** EF Core generates incorrect table names for many-to-many relationships. Always configure them explicitly:

#### **Required Many-to-Many Configurations:**

**Permission ↔ Role:** Table name must be `role_has_permissions`
```csharp
// In PermissionConfiguration.cs
entity.HasMany(p => p.Roles)
    .WithMany(r => r.Permissions)
    .UsingEntity(
        "role_has_permissions",
        l => l.HasOne(typeof(Role)).WithMany().HasForeignKey("role_id").HasPrincipalKey(nameof(Role.Id)),
        r => r.HasOne(typeof(Permission)).WithMany().HasForeignKey("permission_id").HasPrincipalKey(nameof(Permission.Id)),
        j => j.HasKey("role_id", "permission_id"));
```

**FixedPrice ↔ Product:** Table name must be `fixed_price_laundry_products`
```csharp
// In FixedPriceConfiguration.cs
entity.HasMany(f => f.Products)
    .WithMany(p => p.FixedPrices)
    .UsingEntity(
        "fixed_price_laundry_products",
        l => l.HasOne(typeof(Product)).WithMany().HasForeignKey("product_id").HasPrincipalKey(nameof(Product.Id)),
        r => r.HasOne(typeof(FixedPrice)).WithMany().HasForeignKey("fixed_price_id").HasPrincipalKey(nameof(FixedPrice.Id)),
        j => j.HasKey("fixed_price_id", "product_id"));
```

**OrderFixedPrice ↔ Product:** Table name must be `order_fixed_price_laundry_products`
```csharp
// In OrderFixedPriceConfiguration.cs
entity.HasMany(o => o.Products)
    .WithMany(p => p.OrderFixedPrices)
    .UsingEntity(
        "order_fixed_price_laundry_products",
        l => l.HasOne(typeof(Product)).WithMany().HasForeignKey("product_id").HasPrincipalKey(nameof(Product.Id)),
        r => r.HasOne(typeof(OrderFixedPrice)).WithMany().HasForeignKey("order_fixed_price_id").HasPrincipalKey(nameof(OrderFixedPrice.Id)),
        j => j.HasKey("order_fixed_price_id", "product_id"));
```

---

### **Step 6 — Apply Charset & Collation Globally**

In `DownstairsDbContext.OnModelCreating`:

```csharp
modelBuilder.UseCollation(DatabaseConstants.Collations.Unicode);
modelBuilder.HasCharSet(DatabaseConstants.CharSets.Utf8mb4);
modelBuilder.ApplyConfigurationsFromAssembly(typeof(DownstairsDbContext).Assembly);
```

Do **not** duplicate the charset/collation calls inside individual configuration classes—the global settings above apply to every entity.

---

### **Step 7 — Store Configuration Files in Separate Files**

- Keep one `IEntityTypeConfiguration<T>` per file under `dotnet\src\Downstairs.Infrastructure\Persistence\Configurations`.
- Remove any configuration (and matching repository) that no longer has a corresponding model after the scaffold sweep.
- Avoid reintroducing per-entity charset/collation or other settings already handled globally in `DownstairsDbContext`.

---

### **Step 8 — Create Migration**
After entities and configurations are ready:

1. Run a build so the EF tooling can locate `Downstairs.Infrastructure.dll`:
    - `dotnet build dotnet\Downstairs.sln`
    - _or_ `dotnet publish dotnet\Downstairs.AppHost\Downstairs.AppHost.csproj -c Debug`
2. Create the migration from the `dotnet` directory:

    ```
    dotnet ef migrations add <MeaningfulName> \
        --project src/Downstairs.Infrastructure/Downstairs.Infrastructure.csproj \
        --startup-project Downstairs.AppHost/Downstairs.AppHost.csproj
    ```

**IMPORTANT:** After creating the migration, manually verify and fix decimal columns to include `unsigned`:
- Change `decimal(8,2)` to `decimal(8,2) unsigned` in the migration
- EF Core may not generate the unsigned keyword correctly by itself

---

### **Step 9 — Apply `.editorconfig` Formatting**
Run `dotnet format dotnet\Downstairs.sln` to align with the repository formatting rules.

Ensure:
✔ Naming conventions  
✔ Indentation and spacing  
✔ Braces and layout rules are applied to all files  

---

### **Step 10 — Build Verification**
- Run `dotnet build dotnet\Downstairs.sln`
- Ensure the solution compiles successfully and migrations work
- Execute a targeted test run if possible (`dotnet test dotnet\tests\Downstairs.UnitTests\Downstairs.UnitTests.csproj`)

---

### ✅ Done!

This file ensures consistency every time EF Core entities are regenerated or synchronized with the database schema.

---
